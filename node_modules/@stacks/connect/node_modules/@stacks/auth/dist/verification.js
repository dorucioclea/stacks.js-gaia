"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyAuthResponse = exports.verifyAuthRequestAndLoadManifest = exports.verifyAuthRequest = exports.isRedirectUriValid = exports.isManifestUriValid = exports.isExpirationDateValid = exports.isIssuanceDateValid = exports.doPublicKeysMatchUsername = exports.doPublicKeysMatchIssuer = exports.doSignaturesMatchPublicKeys = void 0;
const jsontokens_1 = require("jsontokens");
const dids_1 = require("./dids");
const encryption_1 = require("@stacks/encryption");
const common_1 = require("@stacks/common");
const provider_1 = require("./provider");
const c32check_1 = require("c32check");
function doSignaturesMatchPublicKeys(token) {
    const payload = jsontokens_1.decodeToken(token).payload;
    if (typeof payload === 'string') {
        throw new Error('Unexpected token payload type of string');
    }
    const publicKeys = payload.public_keys;
    if (publicKeys.length === 1) {
        const publicKey = publicKeys[0];
        try {
            const tokenVerifier = new jsontokens_1.TokenVerifier('ES256k', publicKey);
            return tokenVerifier.verify(token);
        }
        catch (e) {
            return false;
        }
    }
    else {
        throw new Error('Multiple public keys are not supported');
    }
}
exports.doSignaturesMatchPublicKeys = doSignaturesMatchPublicKeys;
function doPublicKeysMatchIssuer(token) {
    const payload = jsontokens_1.decodeToken(token).payload;
    if (typeof payload === 'string') {
        throw new Error('Unexpected token payload type of string');
    }
    const publicKeys = payload.public_keys;
    const addressFromIssuer = dids_1.getAddressFromDID(payload.iss);
    if (publicKeys.length === 1) {
        const addressFromPublicKeys = encryption_1.publicKeyToAddress(publicKeys[0]);
        if (addressFromPublicKeys === addressFromIssuer) {
            return true;
        }
    }
    else {
        throw new Error('Multiple public keys are not supported');
    }
    return false;
}
exports.doPublicKeysMatchIssuer = doPublicKeysMatchIssuer;
async function doPublicKeysMatchUsername(token, nameLookupURL) {
    try {
        const payload = jsontokens_1.decodeToken(token).payload;
        if (typeof payload === 'string') {
            throw new Error('Unexpected token payload type of string');
        }
        if (!payload.username) {
            return true;
        }
        if (payload.username === null) {
            return true;
        }
        if (nameLookupURL === null) {
            return false;
        }
        const username = payload.username;
        const url = `${nameLookupURL.replace(/\/$/, '')}/${username}`;
        const response = await common_1.fetchPrivate(url);
        const responseText = await response.text();
        const responseJSON = JSON.parse(responseText);
        if (responseJSON.hasOwnProperty('address')) {
            const nameOwningAddress = responseJSON.address;
            let nameOwningAddressBtc = nameOwningAddress;
            try {
                nameOwningAddressBtc = c32check_1.c32ToB58(nameOwningAddress, 0);
            }
            catch (_a) { }
            const addressFromIssuer = dids_1.getAddressFromDID(payload.iss);
            if (nameOwningAddressBtc === addressFromIssuer) {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    }
    catch (error) {
        console.log(error);
        console.log('Error checking `doPublicKeysMatchUsername`');
        return false;
    }
}
exports.doPublicKeysMatchUsername = doPublicKeysMatchUsername;
function isIssuanceDateValid(token) {
    const payload = jsontokens_1.decodeToken(token).payload;
    if (typeof payload === 'string') {
        throw new Error('Unexpected token payload type of string');
    }
    if (payload.iat) {
        if (typeof payload.iat !== 'number') {
            return false;
        }
        const issuedAt = new Date(payload.iat * 1000);
        if (new Date().getTime() < issuedAt.getTime()) {
            return false;
        }
        else {
            return true;
        }
    }
    else {
        return true;
    }
}
exports.isIssuanceDateValid = isIssuanceDateValid;
function isExpirationDateValid(token) {
    const payload = jsontokens_1.decodeToken(token).payload;
    if (typeof payload === 'string') {
        throw new Error('Unexpected token payload type of string');
    }
    if (payload.exp) {
        if (typeof payload.exp !== 'number') {
            return false;
        }
        const expiresAt = new Date(payload.exp * 1000);
        if (new Date().getTime() > expiresAt.getTime()) {
            return false;
        }
        else {
            return true;
        }
    }
    else {
        return true;
    }
}
exports.isExpirationDateValid = isExpirationDateValid;
function isManifestUriValid(token) {
    const payload = jsontokens_1.decodeToken(token).payload;
    if (typeof payload === 'string') {
        throw new Error('Unexpected token payload type of string');
    }
    return common_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);
}
exports.isManifestUriValid = isManifestUriValid;
function isRedirectUriValid(token) {
    const payload = jsontokens_1.decodeToken(token).payload;
    if (typeof payload === 'string') {
        throw new Error('Unexpected token payload type of string');
    }
    return common_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);
}
exports.isRedirectUriValid = isRedirectUriValid;
async function verifyAuthRequest(token) {
    if (jsontokens_1.decodeToken(token).header.alg === 'none') {
        throw new Error('Token must be signed in order to be verified');
    }
    const values = await Promise.all([
        isExpirationDateValid(token),
        isIssuanceDateValid(token),
        doSignaturesMatchPublicKeys(token),
        doPublicKeysMatchIssuer(token),
        isManifestUriValid(token),
        isRedirectUriValid(token),
    ]);
    return values.every(val => val);
}
exports.verifyAuthRequest = verifyAuthRequest;
async function verifyAuthRequestAndLoadManifest(token) {
    const valid = await verifyAuthRequest(token);
    if (!valid) {
        throw new Error('Token is an invalid auth request');
    }
    return provider_1.fetchAppManifest(token);
}
exports.verifyAuthRequestAndLoadManifest = verifyAuthRequestAndLoadManifest;
async function verifyAuthResponse(token, nameLookupURL, fallbackLookupURLs) {
    const values = await Promise.all([
        isExpirationDateValid(token),
        isIssuanceDateValid(token),
        doSignaturesMatchPublicKeys(token),
        doPublicKeysMatchIssuer(token),
    ]);
    const usernameMatchings = await Promise.all([nameLookupURL]
        .concat(fallbackLookupURLs || [])
        .map(url => doPublicKeysMatchUsername(token, url)));
    const someUsernameMatches = usernameMatchings.includes(true);
    return !!someUsernameMatches && values.every(val => val);
}
exports.verifyAuthResponse = verifyAuthResponse;
//# sourceMappingURL=verification.js.map