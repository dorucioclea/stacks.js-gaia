"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyECDSA = exports.signECDSA = exports.decryptECIES = exports.encryptECIES = exports.eciesGetJsonStringLength = exports.getSignedCipherObjectWrapper = exports.getCipherObjectWrapper = exports.getBufferFromBN = exports.getHexFromBN = exports.aes256CbcEncrypt = exports.InvalidPublicKeyReason = void 0;
const common_1 = require("@stacks/common");
const elliptic_1 = require("elliptic");
const cryptoRandom_1 = require("./cryptoRandom");
const common_2 = require("@stacks/common");
const keys_1 = require("./keys");
const sha2Hash_1 = require("./sha2Hash");
const hmacSha256_1 = require("./hmacSha256");
const aesCipher_1 = require("./aesCipher");
const utils_1 = require("./utils");
const ecurve = new elliptic_1.ec('secp256k1');
var InvalidPublicKeyReason;
(function (InvalidPublicKeyReason) {
    InvalidPublicKeyReason["InvalidFormat"] = "InvalidFormat";
    InvalidPublicKeyReason["IsNotPoint"] = "IsNotPoint";
})(InvalidPublicKeyReason = exports.InvalidPublicKeyReason || (exports.InvalidPublicKeyReason = {}));
async function aes256CbcEncrypt(iv, key, plaintext) {
    const cipher = await aesCipher_1.createCipher();
    const result = await cipher.encrypt('aes-256-cbc', key, iv, plaintext);
    return result;
}
exports.aes256CbcEncrypt = aes256CbcEncrypt;
async function aes256CbcDecrypt(iv, key, ciphertext) {
    const cipher = await aesCipher_1.createCipher();
    const result = await cipher.decrypt('aes-256-cbc', key, iv, ciphertext);
    return result;
}
async function hmacSha256(key, content) {
    const hmacSha256 = await hmacSha256_1.createHmacSha256();
    return hmacSha256.digest(key, content);
}
function equalConstTime(b1, b2) {
    if (b1.length !== b2.length) {
        return false;
    }
    let res = 0;
    for (let i = 0; i < b1.length; i++) {
        res |= b1[i] ^ b2[i];
    }
    return res === 0;
}
function sharedSecretToKeys(sharedSecret) {
    const hashedSecret = sha2Hash_1.hashSha512Sync(sharedSecret);
    return {
        encryptionKey: hashedSecret.slice(0, 32),
        hmacKey: hashedSecret.slice(32),
    };
}
function allHexChars(maybe) {
    return maybe.match(/^[0-9a-f]+$/i) !== null;
}
function isValidPublicKey(pub) {
    const invalidFormat = {
        result: false,
        reason_data: 'Invalid public key format',
        reason: InvalidPublicKeyReason.InvalidFormat,
    };
    const invalidPoint = {
        result: false,
        reason_data: 'Public key is not a point',
        reason: InvalidPublicKeyReason.IsNotPoint,
    };
    if (pub.length !== 66 && pub.length !== 130)
        return invalidFormat;
    const firstByte = pub.slice(0, 2);
    if (pub.length === 130 && firstByte !== '04')
        return invalidFormat;
    if (pub.length === 66 && firstByte !== '02' && firstByte !== '03')
        return invalidFormat;
    if (!allHexChars(pub))
        return invalidFormat;
    const secp256k1 = new elliptic_1.ec('secp256k1');
    try {
        const keyPair = secp256k1.keyFromPublic(common_1.Buffer.from(pub, 'hex'));
        const result = keyPair.validate();
        return {
            result: result.result,
            reason_data: result.reason,
            reason: result.result ? null : InvalidPublicKeyReason.IsNotPoint,
        };
    }
    catch (e) {
        return invalidPoint;
    }
}
function getHexFromBN(bnInput) {
    const hexOut = bnInput.toString('hex', 64);
    if (hexOut.length === 64) {
        return hexOut;
    }
    else if (hexOut.length < 64) {
        const padding = '0'.repeat(64 - hexOut.length);
        return `${padding}${hexOut}`;
    }
    else {
        throw new Error('Generated a > 32-byte BN for encryption. Failing.');
    }
}
exports.getHexFromBN = getHexFromBN;
function getBufferFromBN(bnInput) {
    const result = bnInput.toArrayLike(common_1.Buffer, 'be', 32);
    if (result.byteLength !== 32) {
        throw new Error('Failed to generate a 32-byte BN');
    }
    return result;
}
exports.getBufferFromBN = getBufferFromBN;
function getCipherObjectWrapper(opts) {
    const shell = {
        iv: '',
        ephemeralPK: '',
        mac: '',
        cipherText: '',
        wasString: !!opts.wasString,
    };
    if (opts.cipherTextEncoding === 'base64') {
        shell.cipherTextEncoding = 'base64';
    }
    const ivLength = 32;
    const ephemeralPKLength = 66;
    const macLength = 64;
    return {
        payloadValuesLength: ivLength + ephemeralPKLength + macLength,
        payloadShell: JSON.stringify(shell),
    };
}
exports.getCipherObjectWrapper = getCipherObjectWrapper;
function getSignedCipherObjectWrapper(payloadShell) {
    const shell = {
        signature: '',
        publicKey: '',
        cipherText: payloadShell,
    };
    const signatureLength = 144;
    const publicKeyLength = 66;
    return {
        signedPayloadValuesLength: signatureLength + publicKeyLength,
        signedPayloadShell: JSON.stringify(shell),
    };
}
exports.getSignedCipherObjectWrapper = getSignedCipherObjectWrapper;
function eciesGetJsonStringLength(opts) {
    const { payloadShell, payloadValuesLength } = getCipherObjectWrapper(opts);
    const cipherTextLength = utils_1.getAesCbcOutputLength(opts.contentLength);
    let encodedCipherTextLength;
    if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {
        encodedCipherTextLength = cipherTextLength * 2;
    }
    else if (opts.cipherTextEncoding === 'base64') {
        encodedCipherTextLength = utils_1.getBase64OutputLength(cipherTextLength);
    }
    else {
        throw new Error(`Unexpected cipherTextEncoding "${opts.cipherTextEncoding}"`);
    }
    if (!opts.sign) {
        return payloadShell.length + payloadValuesLength + encodedCipherTextLength;
    }
    else {
        const { signedPayloadShell, signedPayloadValuesLength } = getSignedCipherObjectWrapper(payloadShell);
        return (signedPayloadShell.length +
            signedPayloadValuesLength +
            payloadValuesLength +
            encodedCipherTextLength);
    }
}
exports.eciesGetJsonStringLength = eciesGetJsonStringLength;
async function encryptECIES(publicKey, content, wasString, cipherTextEncoding) {
    const validity = isValidPublicKey(publicKey);
    if (!validity.result) {
        throw validity;
    }
    const ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();
    const ephemeralSK = ecurve.genKeyPair();
    const ephemeralPK = common_1.Buffer.from(ephemeralSK.getPublic().encodeCompressed());
    const sharedSecret = ephemeralSK.derive(ecPK);
    const sharedSecretBuffer = getBufferFromBN(sharedSecret);
    const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);
    const initializationVector = cryptoRandom_1.randomBytes(16);
    const cipherText = await aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, content);
    const macData = common_1.Buffer.concat([initializationVector, ephemeralPK, cipherText]);
    const mac = await hmacSha256(sharedKeys.hmacKey, macData);
    let cipherTextString;
    if (!cipherTextEncoding || cipherTextEncoding === 'hex') {
        cipherTextString = cipherText.toString('hex');
    }
    else if (cipherTextEncoding === 'base64') {
        cipherTextString = cipherText.toString('base64');
    }
    else {
        throw new Error(`Unexpected cipherTextEncoding "${cipherTextEncoding}"`);
    }
    const result = {
        iv: initializationVector.toString('hex'),
        ephemeralPK: ephemeralPK.toString('hex'),
        cipherText: cipherTextString,
        mac: mac.toString('hex'),
        wasString: !!wasString,
    };
    if (cipherTextEncoding && cipherTextEncoding !== 'hex') {
        result.cipherTextEncoding = cipherTextEncoding;
    }
    return result;
}
exports.encryptECIES = encryptECIES;
async function decryptECIES(privateKey, cipherObject) {
    const ecSK = ecurve.keyFromPrivate(privateKey, 'hex');
    let ephemeralPK = null;
    try {
        ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();
    }
    catch (error) {
        throw new common_2.FailedDecryptionError('Unable to get public key from cipher object. ' +
            'You might be trying to decrypt an unencrypted object.');
    }
    const sharedSecret = ecSK.derive(ephemeralPK);
    const sharedSecretBuffer = getBufferFromBN(sharedSecret);
    const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);
    const ivBuffer = common_1.Buffer.from(cipherObject.iv, 'hex');
    let cipherTextBuffer;
    if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {
        cipherTextBuffer = common_1.Buffer.from(cipherObject.cipherText, 'hex');
    }
    else if (cipherObject.cipherTextEncoding === 'base64') {
        cipherTextBuffer = common_1.Buffer.from(cipherObject.cipherText, 'base64');
    }
    else {
        throw new Error(`Unexpected cipherTextEncoding "${cipherObject.cipherText}"`);
    }
    const macData = common_1.Buffer.concat([
        ivBuffer,
        common_1.Buffer.from(ephemeralPK.encodeCompressed()),
        cipherTextBuffer,
    ]);
    const actualMac = await hmacSha256(sharedKeys.hmacKey, macData);
    const expectedMac = common_1.Buffer.from(cipherObject.mac, 'hex');
    if (!equalConstTime(expectedMac, actualMac)) {
        throw new common_2.FailedDecryptionError('Decryption failed: failure in MAC check');
    }
    const plainText = await aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);
    if (cipherObject.wasString) {
        return plainText.toString();
    }
    else {
        return plainText;
    }
}
exports.decryptECIES = decryptECIES;
function signECDSA(privateKey, content) {
    const contentBuffer = content instanceof common_1.Buffer ? content : common_1.Buffer.from(content);
    const ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');
    const publicKey = keys_1.getPublicKeyFromPrivate(privateKey);
    const contentHash = sha2Hash_1.hashSha256Sync(contentBuffer);
    const signature = ecPrivate.sign(contentHash);
    const signatureString = signature.toDER('hex');
    return {
        signature: signatureString,
        publicKey,
    };
}
exports.signECDSA = signECDSA;
function getBuffer(content) {
    if (content instanceof common_1.Buffer)
        return content;
    else if (content instanceof ArrayBuffer)
        return common_1.Buffer.from(content);
    else
        return common_1.Buffer.from(content);
}
function verifyECDSA(content, publicKey, signature) {
    const contentBuffer = getBuffer(content);
    const ecPublic = ecurve.keyFromPublic(publicKey, 'hex');
    const contentHash = sha2Hash_1.hashSha256Sync(contentBuffer);
    return ecPublic.verify(contentHash, signature);
}
exports.verifyECDSA = verifyECDSA;
//# sourceMappingURL=ec.js.map