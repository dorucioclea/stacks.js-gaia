"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ecPairToAddress = exports.ecPairToHexString = exports.hexStringToECPair = exports.getPublicKeyFromPrivate = exports.publicKeyToAddress = exports.makeECPrivateKey = exports.getEntropy = void 0;
const common_1 = require("@stacks/common");
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const cryptoRandom_1 = require("./cryptoRandom");
const sha2Hash_1 = require("./sha2Hash");
const hashRipemd160_1 = require("./hashRipemd160");
function getEntropy(arg) {
    if (!arg) {
        arg = 32;
    }
    return cryptoRandom_1.randomBytes(arg);
}
exports.getEntropy = getEntropy;
function makeECPrivateKey() {
    const keyPair = bitcoinjs_lib_1.ECPair.makeRandom({ rng: getEntropy });
    return keyPair.privateKey.toString('hex');
}
exports.makeECPrivateKey = makeECPrivateKey;
function publicKeyToAddress(publicKey) {
    const publicKeyBuffer = common_1.Buffer.isBuffer(publicKey) ? publicKey : common_1.Buffer.from(publicKey, 'hex');
    const publicKeyHash160 = hashRipemd160_1.hashRipemd160(sha2Hash_1.hashSha256Sync(publicKeyBuffer));
    const result = bitcoinjs_lib_1.address.toBase58Check(publicKeyHash160, bitcoinjs_lib_1.networks.bitcoin.pubKeyHash);
    return result;
}
exports.publicKeyToAddress = publicKeyToAddress;
function getPublicKeyFromPrivate(privateKey) {
    const privateKeyBuffer = common_1.Buffer.isBuffer(privateKey)
        ? privateKey
        : common_1.Buffer.from(privateKey, 'hex');
    const keyPair = bitcoinjs_lib_1.ECPair.fromPrivateKey(privateKeyBuffer);
    return keyPair.publicKey.toString('hex');
}
exports.getPublicKeyFromPrivate = getPublicKeyFromPrivate;
function hexStringToECPair(skHex, network) {
    const ecPairOptions = {
        network: network || bitcoinjs_lib_1.networks.bitcoin,
        compressed: true,
    };
    if (skHex.length === 66) {
        if (skHex.slice(64) !== '01') {
            throw new Error('Improperly formatted private-key hex string. 66-length hex usually ' +
                'indicates compressed key, but last byte must be == 1');
        }
        return bitcoinjs_lib_1.ECPair.fromPrivateKey(common_1.Buffer.from(skHex.slice(0, 64), 'hex'), ecPairOptions);
    }
    else if (skHex.length === 64) {
        ecPairOptions.compressed = false;
        return bitcoinjs_lib_1.ECPair.fromPrivateKey(common_1.Buffer.from(skHex, 'hex'), ecPairOptions);
    }
    else {
        throw new Error('Improperly formatted private-key hex string: length should be 64 or 66.');
    }
}
exports.hexStringToECPair = hexStringToECPair;
function ecPairToHexString(secretKey) {
    const ecPointHex = secretKey.privateKey.toString('hex');
    if (secretKey.compressed) {
        return `${ecPointHex}01`;
    }
    else {
        return ecPointHex;
    }
}
exports.ecPairToHexString = ecPairToHexString;
function ecPairToAddress(keyPair) {
    const sha256 = sha2Hash_1.hashSha256Sync(keyPair.publicKey);
    const hash160 = hashRipemd160_1.hashRipemd160(sha256);
    return bitcoinjs_lib_1.address.toBase58Check(hash160, keyPair.network.pubKeyHash);
}
exports.ecPairToAddress = ecPairToAddress;
//# sourceMappingURL=keys.js.map