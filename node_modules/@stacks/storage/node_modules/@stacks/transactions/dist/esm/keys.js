import { Buffer, hexToBigInt } from '@stacks/common';
import { AddressHashMode, COMPRESSED_PUBKEY_LENGTH_BYTES, UNCOMPRESSED_PUBKEY_LENGTH_BYTES, StacksMessageType, TransactionVersion, PubKeyEncoding, } from './constants';
import { BufferArray, hash160, hashP2PKH, hexStringToInt, intToHexString, leftPadHexToLength, } from './utils';
import { getPublicKey as nobleGetPublicKey, utils, Point, Signature, signSync, } from '@noble/secp256k1';
import { sha256 } from '@noble/hashes/sha256';
import { hmac } from '@noble/hashes/hmac';
import { createMessageSignature, addressHashModeToVersion, addressFromVersionHash, addressToString, } from './common';
import { c32address } from 'c32check';
utils.hmacSha256Sync = (key, ...msgs) => {
    const h = hmac.create(sha256, key);
    msgs.forEach(msg => h.update(msg));
    return h.digest();
};
export function getAddressFromPrivateKey(privateKey, transactionVersion = TransactionVersion.Mainnet) {
    const pubKey = pubKeyfromPrivKey(privateKey);
    return getAddressFromPublicKey(pubKey.data, transactionVersion);
}
export function getAddressFromPublicKey(publicKey, transactionVersion = TransactionVersion.Mainnet) {
    publicKey = typeof publicKey === 'string' ? publicKey : publicKey.toString('hex');
    const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);
    const addr = addressFromVersionHash(addrVer, hashP2PKH(Buffer.from(publicKey, 'hex')));
    const addrString = addressToString(addr);
    return addrString;
}
export function createStacksPublicKey(key) {
    return {
        type: StacksMessageType.PublicKey,
        data: Buffer.from(key, 'hex'),
    };
}
export function publicKeyFromSignature(message, messageSignature, pubKeyEncoding = PubKeyEncoding.Compressed) {
    const parsedSignature = parseRecoverableSignature(messageSignature.data);
    const signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));
    const point = Point.fromSignature(message, signature, parsedSignature.recoveryParam);
    const compressed = pubKeyEncoding === PubKeyEncoding.Compressed;
    return point.toHex(compressed);
}
export function publicKeyFromBuffer(data) {
    return { type: StacksMessageType.PublicKey, data };
}
export function isCompressed(key) {
    return !key.data.toString('hex').startsWith('04');
}
export function publicKeyToString(key) {
    return key.data.toString('hex');
}
export function serializePublicKey(key) {
    const bufferArray = new BufferArray();
    bufferArray.push(key.data);
    return bufferArray.concatBuffer();
}
export function isPrivateKeyCompressed(key) {
    const data = typeof key === 'string' ? Buffer.from(key, 'hex') : key;
    let compressed = false;
    if (data.length === 33) {
        if (data[data.length - 1] !== 1) {
            throw new Error('Improperly formatted private-key. 33 byte length usually ' +
                'indicates compressed key, but last byte must be == 0x01');
        }
        compressed = true;
    }
    else if (data.length === 32) {
        compressed = false;
    }
    else {
        throw new Error(`Improperly formatted private-key hex string: length should be 32 or 33 bytes, provided with length ${data.length}`);
    }
    return compressed;
}
export function pubKeyfromPrivKey(privateKey) {
    const privKey = createStacksPrivateKey(privateKey);
    const isCompressed = isPrivateKeyCompressed(privateKey);
    const pubKey = nobleGetPublicKey(privKey.data.slice(0, 32), isCompressed || privKey.compressed);
    return createStacksPublicKey(utils.bytesToHex(pubKey));
}
export function compressPublicKey(publicKey) {
    const hex = typeof publicKey === 'string' ? publicKey : utils.bytesToHex(publicKey);
    const compressed = Point.fromHex(hex).toHex(true);
    return createStacksPublicKey(compressed);
}
export function deserializePublicKey(bufferReader) {
    const fieldId = bufferReader.readUInt8();
    const keyLength = fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;
    return publicKeyFromBuffer(Buffer.concat([Buffer.from([fieldId]), bufferReader.readBuffer(keyLength)]));
}
export function createStacksPrivateKey(key) {
    const data = typeof key === 'string' ? Buffer.from(key, 'hex') : key;
    const compressed = isPrivateKeyCompressed(key);
    return { data, compressed };
}
export function makeRandomPrivKey() {
    return createStacksPrivateKey(utils.bytesToHex(utils.randomPrivateKey()));
}
export function signWithKey(privateKey, input) {
    const [rawSignature, recoveryParam] = signSync(input, privateKey.data.slice(0, 32), {
        canonical: true,
        recovered: true,
    });
    const signature = Signature.fromHex(rawSignature);
    const coordinateValueBytes = 32;
    const r = leftPadHexToLength(signature.r.toString(16), coordinateValueBytes * 2);
    const s = leftPadHexToLength(signature.s.toString(16), coordinateValueBytes * 2);
    if (recoveryParam === undefined || recoveryParam === null) {
        throw new Error('"signature.recoveryParam" is not set');
    }
    const recoveryParamHex = intToHexString(recoveryParam, 1);
    const recoverableSignatureString = recoveryParamHex + r + s;
    return createMessageSignature(recoverableSignatureString);
}
export function getSignatureRecoveryParam(signature) {
    const coordinateValueBytes = 32;
    if (signature.length < coordinateValueBytes * 2 * 2 + 1) {
        throw new Error('Invalid signature');
    }
    const recoveryParamHex = signature.substr(0, 2);
    return hexStringToInt(recoveryParamHex);
}
export function parseRecoverableSignature(signature) {
    const coordinateValueBytes = 32;
    if (signature.length < coordinateValueBytes * 2 * 2 + 1) {
        throw new Error('Invalid signature');
    }
    const recoveryParamHex = signature.substr(0, 2);
    const r = signature.substr(2, coordinateValueBytes * 2);
    const s = signature.substr(2 + coordinateValueBytes * 2, coordinateValueBytes * 2);
    return {
        recoveryParam: hexStringToInt(recoveryParamHex),
        r,
        s,
    };
}
export function getPublicKey(privateKey) {
    return pubKeyfromPrivKey(privateKey.data);
}
export function privateKeyToString(privateKey) {
    return privateKey.data.toString('hex');
}
export function publicKeyToAddress(version, publicKey) {
    return c32address(version, hash160(publicKey.data).toString('hex'));
}
//# sourceMappingURL=keys.js.map