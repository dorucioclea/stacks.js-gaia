"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBlockstackErrorFromResponse = exports.getBucketUrl = exports.connectToGaiaHub = exports.getFullReadUrl = exports.deleteFromGaiaHub = exports.uploadToGaiaHub = exports.BLOCKSTACK_GAIA_HUB_LABEL = void 0;
const common_1 = require("@stacks/common");
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const jsontokens_1 = require("jsontokens");
const encryption_1 = require("@stacks/encryption");
const common_2 = require("@stacks/common");
exports.BLOCKSTACK_GAIA_HUB_LABEL = 'blockstack-gaia-hub-config';
async function uploadToGaiaHub(filename, contents, hubConfig, contentType = 'application/octet-stream', newFile = true, etag, dangerouslyIgnoreEtag) {
    common_2.Logger.debug(`uploadToGaiaHub: uploading ${filename} to ${hubConfig.server}`);
    const headers = {
        'Content-Type': contentType,
        Authorization: `bearer ${hubConfig.token}`,
    };
    if (!dangerouslyIgnoreEtag) {
        if (newFile) {
            headers['If-None-Match'] = '*';
        }
        else if (etag) {
            headers['If-Match'] = etag;
        }
    }
    const response = await common_2.fetchPrivate(`${hubConfig.server}/store/${hubConfig.address}/${filename}`, {
        method: 'POST',
        headers,
        body: contents,
    });
    if (!response.ok) {
        throw await getBlockstackErrorFromResponse(response, 'Error when uploading to Gaia hub.', hubConfig);
    }
    const responseText = await response.text();
    return JSON.parse(responseText);
}
exports.uploadToGaiaHub = uploadToGaiaHub;
async function deleteFromGaiaHub(filename, hubConfig) {
    common_2.Logger.debug(`deleteFromGaiaHub: deleting ${filename} from ${hubConfig.server}`);
    const response = await common_2.fetchPrivate(`${hubConfig.server}/delete/${hubConfig.address}/${filename}`, {
        method: 'DELETE',
        headers: {
            Authorization: `bearer ${hubConfig.token}`,
        },
    });
    if (!response.ok) {
        throw await getBlockstackErrorFromResponse(response, 'Error deleting file from Gaia hub.', hubConfig);
    }
}
exports.deleteFromGaiaHub = deleteFromGaiaHub;
function getFullReadUrl(filename, hubConfig) {
    return Promise.resolve(`${hubConfig.url_prefix}${hubConfig.address}/${filename}`);
}
exports.getFullReadUrl = getFullReadUrl;
function makeLegacyAuthToken(challengeText, signerKeyHex) {
    let parsedChallenge;
    try {
        parsedChallenge = JSON.parse(challengeText);
    }
    catch (err) {
        throw new Error('Failed in parsing legacy challenge text from the gaia hub.');
    }
    if (parsedChallenge[0] === 'gaiahub' && parsedChallenge[3] === 'blockstack_storage_please_sign') {
        const signer = encryption_1.hexStringToECPair(signerKeyHex + (signerKeyHex.length === 64 ? '01' : ''));
        const digest = encryption_1.hashSha256Sync(common_1.Buffer.from(challengeText));
        const signatureBuffer = signer.sign(digest);
        const signatureWithHash = bitcoinjs_lib_1.script.signature.encode(signatureBuffer, bitcoinjs_lib_1.Transaction.SIGHASH_NONE);
        const signature = signatureWithHash.toString('hex').slice(0, -2);
        const publickey = encryption_1.getPublicKeyFromPrivate(signerKeyHex);
        const token = common_1.Buffer.from(JSON.stringify({ publickey, signature })).toString('base64');
        return token;
    }
    else {
        throw new Error('Failed to connect to legacy gaia hub. If you operate this hub, please update.');
    }
}
function makeV1GaiaAuthToken(hubInfo, signerKeyHex, hubUrl, associationToken) {
    const challengeText = hubInfo.challenge_text;
    const handlesV1Auth = hubInfo.latest_auth_version && parseInt(hubInfo.latest_auth_version.slice(1), 10) >= 1;
    const iss = encryption_1.getPublicKeyFromPrivate(signerKeyHex);
    if (!handlesV1Auth) {
        return makeLegacyAuthToken(challengeText, signerKeyHex);
    }
    const salt = encryption_1.randomBytes(16).toString('hex');
    const payload = {
        gaiaChallenge: challengeText,
        hubUrl,
        iss,
        salt,
        associationToken: associationToken,
    };
    const token = new jsontokens_1.TokenSigner('ES256K', signerKeyHex).sign(payload);
    return `v1:${token}`;
}
async function connectToGaiaHub(gaiaHubUrl, challengeSignerHex, associationToken) {
    common_2.Logger.debug(`connectToGaiaHub: ${gaiaHubUrl}/hub_info`);
    const response = await common_2.fetchPrivate(`${gaiaHubUrl}/hub_info`);
    const hubInfo = await response.json();
    const readURL = hubInfo.read_url_prefix;
    const token = makeV1GaiaAuthToken(hubInfo, challengeSignerHex, gaiaHubUrl, associationToken);
    const address = encryption_1.ecPairToAddress(encryption_1.hexStringToECPair(challengeSignerHex + (challengeSignerHex.length === 64 ? '01' : '')));
    return {
        url_prefix: readURL,
        max_file_upload_size_megabytes: hubInfo.max_file_upload_size_megabytes,
        address,
        token,
        server: gaiaHubUrl,
    };
}
exports.connectToGaiaHub = connectToGaiaHub;
async function getBucketUrl(gaiaHubUrl, appPrivateKey) {
    const challengeSigner = bitcoinjs_lib_1.ECPair.fromPrivateKey(common_1.Buffer.from(appPrivateKey, 'hex'));
    const response = await common_2.fetchPrivate(`${gaiaHubUrl}/hub_info`);
    const responseText = await response.text();
    const responseJSON = JSON.parse(responseText);
    const readURL = responseJSON.read_url_prefix;
    const address = encryption_1.ecPairToAddress(challengeSigner);
    const bucketUrl = `${readURL}${address}/`;
    return bucketUrl;
}
exports.getBucketUrl = getBucketUrl;
async function getGaiaErrorResponse(response) {
    let responseMsg = '';
    let responseJson;
    try {
        responseMsg = await response.text();
        try {
            responseJson = JSON.parse(responseMsg);
        }
        catch (error) {
        }
    }
    catch (error) {
        common_2.Logger.debug(`Error getting bad http response text: ${error}`);
    }
    const status = response.status;
    const statusText = response.statusText;
    const body = responseJson || responseMsg;
    return { status, statusText, body };
}
async function getBlockstackErrorFromResponse(response, errorMsg, hubConfig) {
    if (response.ok) {
        throw new Error('Cannot get a BlockstackError from a valid response.');
    }
    const gaiaResponse = await getGaiaErrorResponse(response);
    if (gaiaResponse.status === 401) {
        return new common_2.ValidationError(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 402) {
        return new common_2.NotEnoughProofError(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 403) {
        return new common_2.BadPathError(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 404) {
        throw new common_2.DoesNotExist(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 409) {
        return new common_2.ConflictError(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 412) {
        return new common_2.PreconditionFailedError(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 413) {
        const maxBytes = hubConfig && hubConfig.max_file_upload_size_megabytes
            ? common_2.megabytesToBytes(hubConfig.max_file_upload_size_megabytes)
            : 0;
        return new common_2.PayloadTooLargeError(errorMsg, gaiaResponse, maxBytes);
    }
    else {
        return new Error(errorMsg);
    }
}
exports.getBlockstackErrorFromResponse = getBlockstackErrorFromResponse;
//# sourceMappingURL=hub.js.map